<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>LAB5</title>
    <link rel="stylesheet" type="text/css" href="main.css">
    
</head>
<body>

    <hr class="thick-line">

    <div class="title">
        <h1 id="header-animation">INTERNET-PROGRAMMING SHOP</h1>
    </div>
    <hr>
    <nav>
        <a href="./index.html" class="selected">MAIN</a>
        <a href="./login.html">로그인</a>
        <a href="./signup.html">회원가입</a>
    </nav>
    
    <hr>

    <section>
        <article>
            <p class="market-title">GAME MARKET</p>
            <hr class="sub-line">
        </article>

        <div class="main">
            <aside>
                <form>
                    <div class="category">
                        <label for="category">Choose a category:</label>
                        <br>
                        <select id="category">
                            <option selected>All</option>
                            <option>Hero</option>
                            <option>Enemy</option>
                            <option>Weapon</option>
                        </select>
                    </div>
                    <div class="term">
                        <label for="search-term">Enter search term:</label>
                        <br>
                        <input id="search-term" type="text" placeholder="e.g. monster">
                    </div>
                    <div>
                        <button id="filter-results">Filter results</button>
                    </div>
                </form>
            </aside>

            <article class="article-content">


            </article>
        </div>
    </section>

    <section>
        <article>
            <p class="market-title">CONTACT</p>
            <hr class="sub-line">
        </article>
        <article>
            <p class="contact-content">
                010-1234-5678 서울특별시 종로구 청와대로 1
                010-1234-5678 서울특별시 종로구 청와대로 1
                010-1234-5678 서울특별시 종로구 청와대로 1
                010-1234-5678 서울특별시 종로구 청와대로 1
                010-1234-5678 서울특별시 종로구 청와대로 1
                010-1234-5678 서울특별시 종로구 청와대로 1
                010-1234-5678 서울특별시 종로구 청와대로 1
                010-1234-5678 서울특별시 종로구 청와대로 1
                010-1234-5678 서울특별시 종로구 청와대로 1
                010-1234-5678 서울특별시 종로구 청와대로 1
            </p>
        </article>
    </section>

    <hr>

    <script>

        //         let count = 1;
        
        //         fetch('product.json')
        //         .then(response => response.json())
        //         .then(json => init(json))
        //         .catch(error => {
        // 	        console.log('Error: ' + error)
        //         });
        
        //         window.onscroll = () => {
        // 	        if (window.innerHeight + window.scrollY >= document.body.offsetHeight) {
        // 		        load();
        // 	        }
        //         }
        
        //         const category = document.querySelector('#category');
        //         const searchTerm = document.querySelector('#search-term');
        //         const filterBtn = document.querySelector('#filter-results');
        //         const main = document.querySelector('.article-content');
        
        //         let categoryGroup = [];
        //         let filterGroup = [];
        
        //         let recentcategory = '';
        //         let recentsearch = '';
        
        //         function init(products) {
        //             let lastCategory = category.value;
        //             let lastSearch = '';
        
        //             filterGroup = products;
        //             update();
        
        //             filterBtn.addEventListener('click', selectCategory);
        
        //             function selectCategory(e) {
        //                 e.preventDefault();
        
        //                 categoryGroup = [];
        //                 filterGroup = [];
        
        //                 if (category.value === lastCategory && searchTerm.value.trim() === lastSearch) {
        //                     return;
        //                     }
        //                 else {
        //                     lastCategory = category.value;
        //                     lastSearch = searchTerm.value.trim();
        
        //                     if (category.value === 'All') {
        //                         categoryGroup = products;
        //                         selectProducts();
        //                     }
        //                     else {
        //                         const lowerCaseType = category.value.toLowerCase();
        //                         categoryGroup = products.filter( product => product.type === lowerCaseType );
        //                         selectProducts();
        //                     }
        //                 }
        //             }
        //         }
        
        //         function selectProducts() {
        //                 if (searchTerm.value.trim() === '') {
        //                     filterGroup = categoryGroup;
        //                 }
        //                 else {
        //                     const lowerCaseSearchTerm = searchTerm.value.trim().toLowerCase();
        //                     filterGroup = categoryGroup.filter( product => product.name.includes(lowerCaseSearchTerm));
        //                     }
        //                     update();
        //         }
        
        //         function update() {
        //             while (main.firstChild) {
        //             main.removeChild(main.firstChild);
        //             }
        
        //             if (filterGroup.length === 0) {
        //                 const para = document.createElement('p');
        //                 para.textContent = 'No results to display!';
        //                 main.appendChild(para);
        //             }
        //             else {
        //                 for (const product of filterGroup) {
        //                     fetchBlob(product);
        //                 }
        //             }
        //         }
        
        //         function fetchBlob (product) {
        //             let url = `${product.image}`;
                    
        //             fetch(url)
        //             .then(response => response.blob())
        //             .then(blob => {
        //                 show(URL.createObjectURL(blob), product.name, product.price, product.info);
        //             })
        //             .catch(error => {
        //                 console.log('Error: ' + error);
        //             });
        //         }
        
        //         function show(blob, product) {
        //             const objectURL = URL.createObjectURL(blob);
        
        //             const section = document.createElement('section');
        //             const heading = document.createElement('h2');
        //             const para = document.createElement('p');
        //             const image = document.createElement('img');
        
        //             section.setAttribute('class', product.type);
        
        //             heading.textContent = product.name.replace(product.name.charAt(0), product.name.charAt(0).toUpperCase());
        
        //             para.textContent = `$${product.price.toFixed(2)}`;
        
        //             image.src = objectURL;
        //             image.alt = product.name;
        
        //             main.appendChild(section);
        //             section.appendChild(heading);
        //             section.appendChild(para);
        //             section.appendChild(image);
        //         }
        
        //         function load () {
        //             for (let i = (count - 1) * 6; i < count * 6; i++) {
        //                 if (i >= filterGroup.length) {
        //                     break;
        //                 }
        //                 fetchblob(filterGroup[i]);
        //             }
                    
        //             if ((count - 1) * 6 >= filterGroup.length) {
        //                 count = filterGroup.length;
        //             } else {
        //                 count = count + 1;
        //             }
        // }
        








        // let cnt = 1;

        // fetch('product.json')
        // .then(response => response.json())
        // .then(json => init(json))
        // .catch(error => {
        //     console.log('Error: ' + error)
        // });

        // window.onscroll = () => {
        //     if (window.innerHeight + window.scrollY >= document.body.offsetHeight) {
        //         load();
        //     }
        // }

        // let category_group = [];
        // let filter_group = [];

        // let recentcategory = '';
        // let recentsearch = '';

        // const category = document.querySelector('#category');
        // const searchterm = document.querySelector('#search-term');
        // const buttonchk = document.querySelector('#filter-results');
        // const main = document.querySelector('.article-content');

        // function init (product) {
        //     let item_type = category.value;
        //     let item_name = '';
            
        //     filter_group = product;
        //     update();
            
        //     buttonchk.onclick = filtering;
            
        //     function filtering (e) {
        //         e.preventDefault();
        //         cnt = 1;
        //         scrollchk = true;
                
        //         category_group = [];
        //         filter_group = [];
                
        //         if (category.value === recentcategory && searchterm.value.trim() === recentsearch) {
        //             return;
        //         } else {
        //             recentcategory = category.value;
        //             recentsearch = searchterm.value.trim();
                    
        //             if (category.value === 'All') {
        //                 category_group = product;
        //                 selectterm();
        //             } else {
        //                 let lower_type = category.value.toLowerCase();
        //                 for (let i = 0; i < product.length; i++) {
        //                     if (product[i].type === lower_type) {
        //                         category_group.push(product[i]);
        //                     }
        //                 }
        //                 selectterm();
        //             }
        //         }
        //     }
        // }

        // function selectterm () {
        //     if (searchterm.value.trim() !== '') {
        //         let lower_term = searchterm.value.trim().toLowerCase();
        //         for (let i = 0; i < category_group.length; i++) {
        //             if (category_group[i].name.indexOf(lower_term) !== -1) {
        //                 filter_group.push(category_group[i]);
        //             }
        //         }
        //     } else {
        //         filter_group = category_group;
        //     }
            
        //     update();
        // }

        // function update () {
        //     while (main.firstChild) {
        //         main.removeChild(main.firstChild);
        //     }
            
        //     if (filter_group.length === 0) {
        //         const msg = document.createElement('div');
        //         msg.className = 'msg';
        //         msg.innerHTML = 'No results!';
        //         main.appendChild(msg);
        //     } else {
        //         console.log(filter_group.length);
        //         load();
        //     }
        // }

        // function load () {
        //     for (let i = (cnt - 1) * 6; i < cnt * 6; i++) {
        //         if (i >= filter_group.length) {
        //             break;
        //         }
        //         fetchblob(filter_group[i]);
        //     }
            
        //     if ((cnt - 1) * 6 >= filter_group.length) {
        //         cnt = filter_group.length;
        //     } else {
        //         cnt = cnt + 1;
        //     }
        // }

        // function fetchblob (product) {
        //     let url = product.image;
            
        //     fetch(url)
        //     .then(response => response.blob())
        //     .then(blob => {
        //         show(URL.createObjectURL(blob), product.name, product.price, product.info);
        //     })
        //     .catch(error => {
        //         console.log('Error: ' + error);
        //     });
        // }

        // function show (imageURL, productname, productprice, productinfo) {
        //     const div = document.createElement('div');
        //     const img = document.createElement('img');
            
        //     div.className = 'item_display';
        //     div.id = productname + '/' + productprice + '/' + productinfo;
        //     div.addEventListener('click', explain);
            
        //     img.src = imageURL;
        //     img.alt = productname;
        //     img.className = 'newitem';
            
        //     main.appendChild(div);
        //     div.appendChild(img);
        // }

        // function explain (e) {
        //     let targetID = e.target.parentNode.id;
        //     let detaillist = targetID.split('/');
            
        //     if (targetID.indexOf('explain-') === -1) {
        //         e.target.parentNode.id = 'explain-' + targetID;
                
        //         const detail = document.createElement('div');
        //         detail.className = 'item_detail';
        //         let str = '<br>이름: &nbsp;' + detaillist[0] + '<br><br>가격: &nbsp;' + detaillist[1] + ' 원<br><br>설명: &nbsp;' + detaillist[2];
        //         detail.innerHTML = str;
        //         document.getElementById(e.target.parentNode.id).appendChild(detail);
        //     } else {
        //         e.target.parentNode.id = targetID.substring(8);
        //         let chk = document.getElementById(e.target.parentNode.id);
        //         chk.removeChild(chk.childNodes[1]);
        //     }
        // }









        let cnt = 1;

        // document.addEventListener('DOMContentLoaded', load);
        fetch('product.json')
        .then( response => {
            if (!response.ok) {
            throw new Error(`HTTP error: ${response.status}`);
            }
            return response.json();
        })
        .then( json => initialize(json) )
        .catch( err => console.error(`Fetch problem: ${err.message}`) );
        
        window.onscroll = () => {
            if (window.innerHeight + window.scrollY >= document.body.offsetHeight) {
                load();
            }
        }
        
        let categoryGroup = [];
        let finalGroup = [];

        let lastCategory = '';
        let lastSearch = '';
        
        
        const category = document.querySelector('#category');
        const searchTerm = document.querySelector('#search-term');
        const searchBtn = document.querySelector('#filter-results');
        const main = document.querySelector('.article-content');
        

        // sets up the app logic, declares required variables, contains all the other functions
        function initialize(products) {
            // grab the UI elements that we need to manipulate
            // const category = document.querySelector('#category');
            // const searchTerm = document.querySelector('#search-term');
            // const searchBtn = document.querySelector('#filter-results');
            // const main = document.querySelector('.article-content');

            // keep a record of what the last category and search term entered were
            // let lastCategory = category.value;
            // // no search has been made yet
            // let lastSearch = ''

            // these contain the results of filtering by category, and search term
            // finalGroup will contain the products that need to be displayed after
            // the searching has been done. Each will be an array containing objects.
            // Each object will represent a product
            // let categoryGroup;
            // let finalGroup;

            // To start with, set finalGroup to equal the entire products database
            // then run updateDisplay(), so ALL products are displayed initially.
            finalGroup = products;
            updateDisplay();

            // Set both to equal an empty array, in time for searches to be run
            // categoryGroup = [];
            // finalGroup = [];

            // when the search button is clicked, invoke selectCategory() to start
            // a search running to select the category of products we want to display
            searchBtn.addEventListener('click', selectCategory);

        

            function selectCategory(e) {
                // Use preventDefault() to stop the form submitting — that would ruin
                // the experience
                e.preventDefault();
                cnt = 1;
		        scrollchk = true;

                // Set these back to empty arrays, to clear out the previous search
                categoryGroup = [];
                finalGroup = [];

                // if the category and search term are the same as they were the last time a
                // search was run, the results will be the same, so there is no point running
                // it again — just return out of the function
                if (category.value === lastCategory && searchTerm.value.trim() === lastSearch) {
                    return;
                }
                else {
                    // update the record of last category and search term
                    lastCategory = category.value;
                    lastSearch = searchTerm.value.trim();
                    // In this case we want to select all products, then filter them by the search
                    // term, so we just set categoryGroup to the entire JSON object, then run selectProducts()
                    if (category.value === 'All') {
                        categoryGroup = products;
                        selectProducts();
                    // If a specific category is chosen, we need to filter out the products not in that
                    // category, then put the remaining products inside categoryGroup, before running
                    // selectProducts()
                    }
                    else {
                        // the values in the <option> elements are uppercase, whereas the categories
                        // store in the JSON (under "type") are lowercase. We therefore need to convert
                        // to lower case before we do a comparison
                        let lowerCaseType = category.value.toLowerCase();
                        // Filter categoryGroup to contain only products whose type includes the category
                        // categoryGroup = products.filter( product => product.type === lowerCaseType );
                        for(let i = 0; i < products.length; i++) {
                            if (products[i].type === lowerCaseType) {
                                categoryGroup.push(products[i]);
                            }
                        }
                        // Run selectProducts() after the filtering has been done
                        selectProducts();
                    }
                }
            }
        }
        

        // selectProducts() Takes the group of products selected by selectCategory(), and further
        // filters them by the tiered search term (if one has been entered)
        function selectProducts() {
            // If no search term has been entered, just make the finalGroup array equal to the categoryGroup
            // array — we don't want to filter the products further.
            if (searchTerm.value.trim() === '') {
                finalGroup = categoryGroup;
            }
            else {
                // Make sure the search term is converted to lower case before comparison. We've kept the
                // product names all lower case to keep things simple
                let lowerCaseSearchTerm = searchTerm.value.trim().toLowerCase();
                // Filter finalGroup to contain only products whose name includes the search term
                // finalGroup = categoryGroup.filter( product => product.name.includes(lowerCaseSearchTerm));
                for (let i = 0; i < categoryGroup.length; i++) {
                    if (categoryGroup[i].name.indexOf(lowerCaseSearchTerm) !== -1) {
                        finalGroup.push(categoryGroup[i]);
                    }
                }
            }
            // Once we have the final group, update the display
            updateDisplay();
        }

        // start the process of updating the display with the new set of products
        function updateDisplay() {
            // remove the previous contents of the <main> element
            while (main.firstChild) {
                main.removeChild(main.firstChild);
            }

            // if no products match the search term, display a "No results to display" message
            if (finalGroup.length === 0) {
                const para = document.createElement('p');
                para.textContent = 'No results to display!';
                main.appendChild(para);
                // for each product we want to display, pass its product object to fetchBlob()
            }
            else {
                // for (const product of finalGroup) {
                //     fetchBlob(product);
                // }
                // console.log(finalGroup.length);
		        load();
            }
        }

        function load() {
            for (let i = (cnt - 1) * 6; i < cnt * 6; i++) {
                if (i >= finalGroup.length) {
                    break;
                }
                fetchBlob(finalGroup[i]);
                // for (const product of finalGroup) {
                //     fetchBlob(finalGroup[i]);
                // }
            }
            
            if ((cnt - 1) * 6 >= finalGroup.length) {
                cnt = finalGroup.length;
            } else {
                cnt = cnt + 1;
            }
        }

        // function load(){
        //     const start = cnt;
        //     const end = start + 1;
        //     cnt = end + 1;

        //     fetch(`product.json?postID=${start}&postID=${end}`)
        //     .then(response => response.json())
        //     .then(finalGroup =>
        //     finalGroup.forEach(fetchBlob));
            
        // }

        // function add_post(product){
        //     let post = document.createElement('div');
        //     post.classname = 'item_display';
        //     post.innerHTML = `${product.json}`.image;
        //     document.querySelector('.article-content').append(post);
        // }

        // fetchBlob uses fetch to retrieve the image for that product, and then sends the
        // resulting image display URL and product object on to showProduct() to finally
        // display it
        function fetchBlob(product) {
            // construct the URL path to the image file from the product.image property
            const url = product.image;
            // Use fetch to fetch the image, and convert the resulting response to a blob
            // Again, if any errors occur we report them in the console.
            fetch(url)
            .then(response => response.blob())
            .then(blob => {
                showProduct(URL.createObjectURL(blob), product.name, product.price);
            })
            .catch(error => {
                console.log('Error: ' + error);
            });
                }

    // // Display a product inside the <main> element
    // function showProduct(blob, product) {
    //     // Convert the blob to an object URL — this is basically an temporary internal URL
    //     // that points to an object stored inside the browser
    //     const objectURL = URL.createObjectURL(blob);
    //     // create <section>, <h2>, <p>, and <img> elements
    //     const section = document.createElement('section');
    //     // const heading = document.createElement('h2');
    //     // const para = document.createElement('p');
    //     const image = document.createElement('img');

    //     // give the <section> a classname equal to the product "type" property so it will display the correct icon
    //     section.setAttribute('class', product.type);

    //     // Give the <h2> textContent equal to the product "name" property, but with the first character
    //     // replaced with the uppercase version of the first character
    //     // heading.textContent = product.name.replace(product.name.charAt(0), product.name.charAt(0).toUpperCase());

    //     // Give the <p> textContent equal to the product "price" property, with a $ sign in front
    //     // toFixed(2) is used to fix the price at 2 decimal places, so for example 1.40 is displayed
    //     // as 1.40, not 1.4.
    //     // para.textContent = `$${product.price.toFixed(2)}`;

    //     // Set the src of the <img> element to the ObjectURL, and the alt to the product "name" property
    //     image.src = objectURL;
    //     image.alt = product.name;

    //     // append the elements to the DOM as appropriate, to add the product to the UI
    //     main.appendChild(section);
    //     // section.appendChild(heading);
    //     // section.appendChild(para);
    //     section.appendChild(image);

    //     image.addEventListener('click', explain);

    //     function explain(e) {
    //         const heading = document.createElement('h2');
    //         const para = document.createElement('p');

    //         heading.textContent = product.name.replace(product.name.charAt(0), product.name.charAt(0).toUpperCase());
    //         para.textContent = `$${product.price.toFixed(2)}`;

    //         section.appendChild(heading);
    //         section.appendChild(para);
    //     }
    // }

        function showProduct (imageURL, productname, productprice) {
            const div = document.createElement('div');
            const img = document.createElement('img');
            
            div.className = 'item_display';
            div.id = productname + '/' + productprice + '/';
            div.addEventListener('click', explain);
            
            img.src = imageURL;
            img.alt = productname;
            img.className = 'newitem';
            
            main.appendChild(div);
            div.appendChild(img);
        }

        function explain (e) {
            let targetID = e.target.parentNode.id;
            let detaillist = targetID.split('/');
            
            if (targetID.indexOf('explain-') === -1) {
                e.target.parentNode.id = 'explain-' + targetID;
                
                const detail = document.createElement('div');
                detail.className = 'item_detail';
                let str = '<br>이름: &nbsp;' + detaillist[0] + '<br><br>가격: &nbsp;' + detaillist[1];
                detail.innerHTML = str;
                document.getElementById(e.target.parentNode.id).appendChild(detail);
            } else {
                e.target.parentNode.id = targetID.substring(8);
                let chk = document.getElementById(e.target.parentNode.id);
                chk.removeChild(chk.childNodes[1]);
            }
        }
        

        
    </script>
</body>
</html>